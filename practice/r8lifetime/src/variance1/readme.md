https://nomicon.purewhite.io/subtyping.html

生命周期只是代码的区域，而区域可以通过包含（比谁活得长）的关系来部分排序。生命周期的子类型是指这种关系：如果'big: 'small（“big 包含 small”或“big 比 small 活得长”），那么'big就是'small的一个子类型。这是一个很大的混乱来源，因为对许多人来说，它似乎是倒过来的：大区域是小区域的子类型。但是如果你考虑我们的动物例子，这就说得通了：猫是一种动物并且拥有更多特征，就像'big是'small的更多一样。

换句话说，如果有人想要一个能在'small中活着的引用，通常他们的意思是，他们想要一个至少能在'small中活着的引用。他们实际上并不关心生命周期是否完全匹配。所以，我们应该可以忘记某个东西的生命周期是'big，而只记得它的生命周期是'small。

生命周期的喵喵狗问题将导致我们能够将一个短生命周期的引用存储在一个期望长生命周期的地方，创造一个悬空的引用，并让我们产生释放后使用（use-after-free）。

值得注意的是，'static，即永远的生命周期，是每个生命周期的子类型，因为根据定义，它比所有的东西都要长。我们将在后面的例子中使用这种关系，以使它们尽可能的简单。

说了这么多，我们仍然不知道如何实际使用生命周期的子类型，因为没有任何东西具有'a的类型。生命周期只作为一些更大的类型的一部分出现，如&'a u32或IterMut<'a, u32>。为了应用生命周期子类型，我们需要知道如何组成子类型。因此，我们需要型变。